{"id":1,"parentId":-1,"label":"snippets","lastId":18,"children":[{"id":3,"parentId":1,"label":"cpp","folder":true,"children":[{"id":2,"parentId":3,"label":"cpp vector func","value":"// vector的成员函数用法\n// TODO\nvector<int> v{1,2,3,4};\nv.erase(v.begin(),v.begin()+2); // 删除前两个;","children":[],"resolveSyntax":true},{"id":4,"parentId":3,"label":"cpp headers","value":"#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<list>\n#include<unordered_map>\n#include<unordered_set>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<limits>\n#include<map>\n#include<set>\nusing namespace std;","children":[],"resolveSyntax":true},{"id":5,"parentId":3,"label":"cpp exe redirect","value":"Get-Content input.txt | .\\VSCode\\test.exe >output.txt","children":[]},{"id":6,"parentId":3,"label":"cpp cout precision","value":"    // cout << setprecision(4)<< bb<<endl; // 设置精度, 一直有效; #include <iomanip> //需要包含的头文件\r\n    // cout << fixed << setprecision(4) << bb << endl; // fixed表示按小数点后保留4位小数，没有fixed则是4位有效数字；一直有效；\r\n    // cout.unsetf(ios::fixed); // 取消fixed;\r\n    // cout.precision(6); // 恢复默认精度;","children":[]},{"id":8,"parentId":3,"label":"cpp printVector","value":"template<class T>\r\nvoid printVector(vector<T> v) {\r\n    for(auto n:v) {\r\n        cout<<n<<\" \";\r\n    }\r\n    cout<<endl;\r\n    // for(auto n:v) {\r\n    //     cout<<n<<endl;\r\n    // }\r\n}","children":[]},{"id":7,"parentId":3,"label":"cpp main","value":"void solve() {\r\n\r\n    int n, m;\r\n    cin >> n >> m;\r\n    cout<<n+m<<endl;\r\n\r\n}\r\n\r\nint main() {\r\n\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n    while (t--) {\r\n        solve();\r\n    }\r\n\r\n    return 0;\r\n}","children":[]},{"id":9,"parentId":3,"label":"cpp dfs TreeNoRoot","value":"const int N=100001;\r\nvector<vector<int>> edges(N+1, vector<int>()); // edges[i] = {j1, j2, ...}表示无向边i-j1, i-j2\r\nvector<int> dist(100001); // 距离数组；\r\nvoid dfs_Tree(int u, int par) {\r\n    // 在不确定方向的Tree的某节点开始上dfs，确定到u距离\r\n    for (auto v : edges[u]) { // u-v\r\n        if (v == par) {\r\n            continue;\r\n        }\r\n        dist[v] = dist[u] + 1;\r\n        dfs_Tree(v, u);\r\n    }\r\n}","children":[]},{"id":10,"parentId":3,"label":"cpp isPrime","value":"bool isPrime(int n) {\r\n    if(n==2||n==3||n==5||n==7)\r\n        return true;\r\n    for(int i=2;i<=n/2;i++) {\r\n        if(n%i==0)\r\n            return false;\r\n    }\r\n    return true;\r\n}","children":[]},{"id":11,"parentId":3,"label":"cpp direction array","value":"// 方向数组：direction array\n// 右下 (下是x增大，右是y增大)\nvector<vector<int>> direction2{{0,1},{1,0}};\n// 上下左右\nvector<vector<int>> direction4{{-1,0},{1,0},{0,-1},{0,1}};\n// 上下左右，和4个斜对角方向; 从上开始顺时针方向;\nvector<vector<int>> direction8{{-1,0},{-1,1},{0,1},{1,1},\n                                {1,0},{1,-1},{0,-1},{-1,-1}};\n// examples\nvoid printNextPositions4(int x,int y, int m, int n) {\n    // position = (x, y), grid shape = m*n; x in [0, m), y in [0, n)\n    cout<< \"next positions of (\"<<x<<\",\"<<y<<\") is \"<<endl;\n    // driection=4, 上下左右\n    for(auto dir: direction4) {\n        int new_x=x+dir[0];\n        int new_y=y+dir[1];\n        // ! 特别注意x,y和m,n对应关系，千万别反了\n        if(new_x<0 || new_x>=m) continue;\n        if(new_y<0 || new_y>=n) continue;\n        // using new_position (new_x, new_y)\n        cout<< \"(\"<<new_x << \",\"<<new_y<<\")\"<<endl;\n    }\n}","children":[],"resolveSyntax":true},{"id":12,"parentId":3,"label":"cpp direction array faster","value":"// 更快的方向数组：direction array faster\n// 右下 (下是x增大，右是y增大)\nint arrayDirection2[2][2]={{0,1},{1,0}};\n// 上下左右\nint arrayDirection4[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n// 上下左右，和4个斜对角方向; 从上开始顺时针方向;\nint arrayDirection8[8][2]={{-1,0},{-1,1},{0,1},{1,1},\n                                {1,0},{1,-1},{0,-1},{-1,-1}};\n// examples\nvoid printNextPositions4(int x,int y, int m, int n) {\n    // position = (x, y), grid shape = m*n; x in [0, m), y in [0, n)\n    cout<< \"next positions of (\"<<x<<\",\"<<y<<\") is \"<<endl;\n    // driection=4, 上下左右\n    for(int i=0;i<4;++i) {\n        int new_x= x + arrayDirection4[i][0];\n        int new_y= y + arrayDirection4[i][1];\n        // ! 特别注意x,y和m,n对应关系，千万别反了\n        if(new_x<0 || new_x>=m) continue;\n        if(new_y<0 || new_y>=n) continue;\n        // using new_position (new_x, new_y)\n        cout<< \"(\"<<new_x << \",\"<<new_y<<\")\"<<endl;\n    }\n}","children":[],"resolveSyntax":true},{"id":13,"parentId":3,"label":"cpp for","value":"for(int ${1|i,j,k|}=${2:0};$1<${3:n};++$1) {\r\n    $0\r\n}","children":[]},{"id":14,"parentId":3,"label":"cpp while","value":"int ${1|i,j,k|}=${2:0};\nwhile($1<${3:n}) {\n    $0\n\n    ++$1;\n}","children":[],"resolveSyntax":true}]},{"id":15,"parentId":1,"label":"python","folder":true,"children":[{"id":16,"parentId":15,"label":"Snippet new one","value":"snippet中使用相对缩进，会根据要插入的位置相应调整，所以构建snippet时只需要相对无缩进进行缩进即可。\n特别注意选中代码段右键New Snippet和New Snippet from ClipBoard需要去掉一部分缩进。\n推荐新建后立即插入一个试试；","resolveSyntax":true},{"id":17,"parentId":15,"label":"Snippet Syntax","value":"/*see more at https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax\nTabStops: \\$1, \\$2 for cursor locations, \\$0 for final cursor position.\n--\\$1等可出现多次，多处会同时改变；\n--Snippet要显示特殊字符,例如\\$,可使用反斜杠+特殊字符形式，就如此Snippet所示\nPlaceholders: \\${1:foo} set the default value of \\$1\nChoice: \\${1|one,two,three|} set the choice value of \\$1\n--在\\$1等出现多次时，默认值和默认选项可只在第一处设置；\nVariables: \\$name or \\${name:default} for variables, like 文件名：TM_FILENAME, 小时：CURRENT_HOUR等\n--see more in link\n*/","children":[],"resolveSyntax":true}]},{"id":18,"parentId":1,"label":"22","folder":true,"children":[]}]}