{"id":1,"parentId":-1,"label":"snippets","lastId":34,"children":[{"id":19,"parentId":1,"label":"cpp","folder":true,"children":[{"id":21,"parentId":19,"label":"cpp vector func","value":"// vector的成员函数用法\r\n// TODO\r\nvector<int> v{1,2,3,4};\r\nv.erase(v.begin(),v.begin()+2); // 删除前两个;","children":[]},{"id":22,"parentId":19,"label":"cpp headers","value":"#include<iostream>\r\n#include<string>\r\n#include<vector>\r\n#include<stack>\r\n#include<queue>\r\n#include<deque>\r\n#include<list>\r\n#include<unordered_map>\r\n#include<unordered_set>\r\n#include<algorithm>\r\n#include<cassert>\r\n#include<cmath>\r\n#include<cctype>\r\n#include<limits>\r\n#include<map>\r\n#include<set>\r\nusing namespace std;","children":[]},{"id":23,"parentId":19,"label":"cpp exe redirect","value":"Get-Content input.txt | .\\VSCode\\test.exe >output.txt","children":[]},{"id":24,"parentId":19,"label":"cpp cout precision","value":"cout << setprecision(4)<< bb<<endl; // 设置精度, 一直有效; #include <iomanip> //需要包含的头文件\r\ncout << fixed << setprecision(4) << bb << endl; // fixed表示按小数点后保留4位小数，没有fixed则是4位有效数字；一直有效；\r\ncout.unsetf(ios::fixed); // 取消fixed;\r\ncout.precision(6); // 恢复默认精度;","children":[]},{"id":25,"parentId":19,"label":"cpp printVector","value":"template<class T>\r\nvoid printVector(vector<T> v) {\r\n    for(auto n:v) {\r\n        cout<<n<<\" \";\r\n    }\r\n    cout<<endl;\r\n    // for(auto n:v) {\r\n    //     cout<<n<<endl;\r\n    // }\r\n}","children":[]},{"id":26,"parentId":19,"label":"cpp printVectorVector","value":"template<class T>\r\nvoid printVectorVector(vector<vector<T>> nums) {\r\n    cout<<\"[\";\r\n    for(int i=0;i<nums.size();++i) {\r\n        cout<< \"[\";\r\n        for(int j=0;j<nums[i].size();++j) {\r\n            cout<< nums[i][j];\r\n            if(j+1<nums[i].size()) { // 无符号数\r\n                cout<< \",\";\r\n            }\r\n        }\r\n        cout<<\"]\";\r\n        if(i+1<nums.size()) {\r\n            cout<<\",\";\r\n        }\r\n    }\r\n    cout<<\"]\"<<endl;\r\n\r\n    // 无中括号，以空格和换行分隔\r\n    // for(int i=0;i<nums.size();++i) {\r\n    //     for(int j=0;j<nums[i].size();++j) {\r\n    //         cout<< nums[i][j]<<\" \";\r\n    //     }\r\n    //     cout<<endl;\r\n    // }\r\n}","children":[]},{"id":28,"parentId":19,"label":"cpp dfs TreeNoRoot","value":"const int N=100001;\r\nvector<vector<int>> edges(N+1, vector<int>()); // edges[i] = {j1, j2, ...}表示无向边i-j1, i-j2\r\nvector<int> dist(100001); // 距离数组；\r\nvoid dfs_Tree(int u, int par) {\r\n    // 在不确定方向的Tree的某节点开始上dfs，确定到u距离\r\n    for (auto v : edges[u]) { // u-v\r\n        if (v == par) {\r\n            continue;\r\n        }\r\n        dist[v] = dist[u] + 1;\r\n        dfs_Tree(v, u);\r\n    }\r\n}","children":[]},{"id":27,"parentId":19,"label":"cpp main","value":"void solve() {\r\n\r\n    int n, m;\r\n    cin >> n >> m;\r\n    cout<<n+m<<endl;\r\n\r\n}\r\n\r\nint main() {\r\n\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n    while (t--) {\r\n        solve();\r\n    }\r\n\r\n    return 0;\r\n}","children":[]},{"id":29,"parentId":19,"label":"isPrime","value":"bool isPrime(int n) {\r\n    if(n==2||n==3||n==5||n==7)\r\n        return true;\r\n    for(int i=2;i<=n/2;i++) {\r\n        if(n%i==0)\r\n            return false;\r\n    }\r\n    return true;\r\n}","children":[]},{"id":30,"parentId":19,"label":"cpp direction array","value":"// 方向数组：direction array\r\n// 右下 (下是x增大，右是y增大)\r\nvector<vector<int>> direction2{{0,1},{1,0}};\r\n// 上下左右\r\nvector<vector<int>> direction4{{-1,0},{1,0},{0,-1},{0,1}};\r\n// 上下左右，和4个斜对角方向; 从上开始顺时针方向;\r\nvector<vector<int>> direction8{{-1,0},{-1,1},{0,1},{1,1},\r\n                                {1,0},{1,-1},{0,-1},{-1,-1}};\r\n// examples\r\nvoid printNextPositions4(int x,int y, int m, int n) {\r\n    // position = (x, y), grid shape = m*n; x in [0, m), y in [0, n)\r\n    cout<< \"next positions of (\"<<x<<\",\"<<y<<\") is \"<<endl;\r\n    // driection=4, 上下左右\r\n    for(auto dir: direction4) {\r\n        int new_x=x+dir[0];\r\n        int new_y=y+dir[1];\r\n        // ! 特别注意x,y和m,n对应关系，千万别反了\r\n        if(new_x<0 || new_x>=m) continue;\r\n        if(new_y<0 || new_y>=n) continue;\r\n        // using new_position (new_x, new_y)\r\n        cout<< \"(\"<<new_x << \",\"<<new_y<<\")\"<<endl;\r\n    }\r\n}","children":[]},{"id":31,"parentId":19,"label":"cpp direction array faster","value":"// 更快的方向数组：direction array faster\r\n// 右下 (下是x增大，右是y增大)\r\nint arrayDirection2[2][2]={{0,1},{1,0}};\r\n// 上下左右\r\nint arrayDirection4[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\r\n// 上下左右，和4个斜对角方向; 从上开始顺时针方向;\r\nint arrayDirection8[8][2]={{-1,0},{-1,1},{0,1},{1,1},\r\n                                {1,0},{1,-1},{0,-1},{-1,-1}};\r\n// examples\r\nvoid printNextPositions4(int x,int y, int m, int n) {\r\n    // position = (x, y), grid shape = m*n; x in [0, m), y in [0, n)\r\n    cout<< \"next positions of (\"<<x<<\",\"<<y<<\") is \"<<endl;\r\n    // driection=4, 上下左右\r\n    for(int i=0;i<4;++i) {\r\n        int new_x= x + arrayDirection4[i][0];\r\n        int new_y= y + arrayDirection4[i][1];\r\n        // ! 特别注意x,y和m,n对应关系，千万别反了\r\n        if(new_x<0 || new_x>=m) continue;\r\n        if(new_y<0 || new_y>=n) continue;\r\n        // using new_position (new_x, new_y)\r\n        cout<< \"(\"<<new_x << \",\"<<new_y<<\")\"<<endl;\r\n    }\r\n}","children":[]},{"id":32,"parentId":19,"label":"cpp for","value":"for(int ${1|i,j,k|}=${2:0};$1<${3:n};++$1) {\r\n    $0\r\n}","children":[]},{"id":33,"parentId":19,"label":"cpp while","value":"int ${1|i,j,k|}=${2:0};\r\nwhile($1<${3:n}) {\r\n    $0\r\n\r\n    ++$1;\r\n}","children":[]}]},{"id":20,"parentId":1,"label":"python","folder":true,"children":[{"id":34,"parentId":20,"label":"python list","value":"# TODO","children":[]}]}]}